<!DOCTYPE html>
<html lang="en" data-bs-theme="dark">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
    <title>Forums - Arcator</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet">
    <link href="https://cdn.jsdelivr.net/npm/quill@2.0.2/dist/quill.snow.css" rel="stylesheet">
    <link href="./styles.css" rel="stylesheet">
    <link href="./favicon.png" rel="icon" type="image/png">
    <script src="https://cdn.jsdelivr.net/npm/dompurify@3.0.8/dist/purify.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/dayjs@1/dayjs.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/sweetalert2@11"></script>
    <script src="https://cdn.jsdelivr.net/npm/quill@2.0.2/dist/quill.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.bundle.min.js"></script>

    <style>
        .ql-editor{min-height:60px;background:#1a1a1a;color:#fff !important}
        .ql-toolbar{background:#222;border-color:#333!important}
        .ql-container{border-color:#333!important}
        .swal2-popup .ql-toolbar { background: #333; border-color: #444; }
        .swal2-popup .ql-container { border-color: #444; background: #222; }
        .forum-thread-card { transition: transform 0.2s; }
        .forum-thread-card:hover { transform: translateY(-2px); }
        .profile-img-sm { width: 24px; height: 24px; border-radius: 50%; object-fit: cover; }
        .message-bubble { max-width: 80%; }
    </style>
</head>
<body>
<div id="navbar-placeholder"></div>

<section class="hero-section">
    <img src="./creativespawn.png" alt="Hero" loading="lazy">
    <div class="hero-overlay"></div>
    <div class="hero-content">
        <h1 class="display-4 fw-bold mb-3">Forums & Messages</h1>
        <p class="lead">Community discussions and conversations</p>
    </div>
</section>

<main class="container py-5" x-data="{ tab: 'forums' }">
    <ul class="nav nav-tabs mb-4">
        <li class="nav-item"><button class="nav-link" :class="{ 'active': tab === 'forums' }" @click="tab = 'forums'">Forums</button></li>
        <li class="nav-item"><button class="nav-link" :class="{ 'active': tab === 'messages' }" @click="tab = 'messages'">Messages</button></li>
    </ul>
    <div class="tab-content">
        <div x-show="tab === 'forums'" x-data="forumData">
            <div class="d-flex justify-content-between align-items-center mb-4">
                <h2 class="h4 mb-0">Forum Threads</h2>
                <template x-if="$store.auth.user">
                    <button class="btn btn-primary btn-sm" @click="showCreateModal = true">Create Thread</button>
                </template>
            </div>
            <div class="card mb-4" x-show="showCreateModal" x-transition>
                <div class="card-body">
                    <h5 class="card-title">Create New Thread</h5>
                    <form @submit.prevent="createThread">
                        <div class="mb-3"><input class="form-control" x-model="newThread.title" placeholder="Title" required></div>
                        <div class="mb-3">
                            <label class="form-label small">Description</label>
                            <div x-ref="createEditor"></div>
                        </div>
                        <div class="row mb-3">
                            <div class="col-md-6">
                                <select class="form-select" x-model="newThread.category" required aria-label="Select Category">
                                    <option value="">Select category...</option>
                                    <option value="announcements">Announcements</option>
                                    <option value="gaming">Gaming</option>
                                    <option value="discussion">Discussion</option>
                                    <option value="support">Support</option>
                                </select>
                            </div>
                            <div class="col-md-6"><input class="form-control" x-model="newThread.tags" placeholder="Tags (comma-separated)"></div>
                        </div>
                        <div class="d-flex gap-2 justify-content-end">
                            <button type="button" class="btn btn-secondary btn-sm" @click="showCreateModal = false">Cancel</button>
                            <button type="submit" class="btn btn-primary btn-sm">Post</button>
                        </div>
                    </form>
                </div>
            </div>
            <div x-show="loading" class="text-center py-5"><div class="spinner-border text-primary"></div></div>
            <div x-show="!loading && threads.length === 0" class="text-center py-5 text-secondary">No threads yet</div>
            <template x-for="thread in threads" :key="thread.id">
                <div class="card mb-2 forum-thread-card">
                    <div class="card-body py-2">
                        <div class="d-flex align-items-center justify-content-between gap-2 flex-wrap">
                            <div class="d-flex align-items-center gap-2">
                                <button class="btn btn-link btn-sm p-0 text-primary" @click="toggleThread(thread)">
                                    <span x-text="thread.expanded ? '‚ñº' : '‚ñ∂'"></span>
                                </button>
                                <span class="fw-bold" x-text="thread.title"></span>
                                <span x-show="thread.censored" class="badge bg-danger">Censored</span>
                            </div>
                            <div class="d-flex align-items-center gap-2">
                                <small class="text-secondary" x-html="getThreadMeta(thread)"></small>
                                <template x-if="$store.auth.isAdmin || ($store.auth.user && $store.auth.user.uid === thread.authorId)">
                                    <div class="dropdown">
                                        <button class="btn btn-link btn-sm p-0 text-secondary" data-bs-toggle="dropdown">
                                            <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-three-dots-vertical" viewBox="0 0 16 16"><path d="M9.5 13a1.5 1.5 0 1 1-3 0 1.5 1.5 0 0 1 3 0zm0-5a1.5 1.5 0 1 1-3 0 1.5 1.5 0 0 1 3 0zm0-5a1.5 1.5 0 1 1-3 0 1.5 1.5 0 0 1 3 0z"/></svg>
                                        </button>
                                        <ul class="dropdown-menu">
                                            <li><a class="dropdown-item" href="#" @click.prevent="editThread(thread)">Edit</a></li>
                                            <template x-if="$store.auth.isAdmin">
                                                <li><a class="dropdown-item" href="#" @click.prevent="softDeleteThread(thread)" x-text="thread.censored ? 'Un-censor' : 'Censor'"></a></li>
                                            </template>
                                            <li><a class="dropdown-item text-danger" href="#" @click.prevent="deleteThread(thread.id)">Delete</a></li>
                                        </ul>
                                    </div>
                                </template>
                            </div>
                        </div>
                        <div x-show="!thread.censored || $store.auth.isAdmin">
                            <p class="mb-0 small mt-1" x-html="DOMPurify.sanitize(thread.description)"></p>
                        </div>
                        <div x-show="thread.censored && !$store.auth.isAdmin" class="alert alert-warning py-1 mt-1 mb-0 small">
                            This content has been censored.
                        </div>
                    </div>
                    <div class="card-footer py-2" x-show="thread.expanded" x-transition>
                        <div x-show="thread.loadingComments" class="text-center py-1"><div class="spinner-border spinner-border-sm"></div></div>
                        <div class="comments-list mb-2">
                            <template x-for="comment in thread.comments.filter(c => !c.parentCommentId)" :key="comment.id">
                                <div class="comment mb-2 ms-0">
                                    <div class="d-flex">
                                        <div class="d-flex flex-column align-items-center me-2">
                                            <button class="btn btn-link btn-sm p-0 text-secondary text-decoration-none" @click="vote(thread.id, comment, 'up')" :class="hasVoted(comment, 'up') ? 'text-primary' : ''">‚ñ≤</button>
                                            <span class="small fw-bold" x-text="getVoteScore(comment)"></span>
                                            <button class="btn btn-link btn-sm p-0 text-secondary text-decoration-none" @click="vote(thread.id, comment, 'down')" :class="hasVoted(comment, 'down') ? 'text-primary' : ''">‚ñº</button>
                                        </div>
                                        <div class="flex-grow-1">
                                            <div class="d-flex align-items-center gap-2 mb-1">
                                                <img :src="getAuthor(comment.authorId).photoURL || './defaultuser.png'" class="profile-img-sm">
                                                <strong x-text="getAuthor(comment.authorId).displayName || 'Unknown'"></strong>
                                                <small class="text-secondary" x-text="formatDate(comment.createdAt)"></small>
                                                <div class="d-flex gap-1 ms-2">
                                                    <template x-for="(count, emoji) in getReactions(comment)" :key="emoji">
                                                        <span class="badge bg-dark border border-secondary text-secondary" x-text="emoji + ' ' + count" style="font-size: 0.7em;"></span>
                                                    </template>
                                                </div>
                                                <template x-if="$store.auth.isAdmin || ($store.auth.user && $store.auth.user.uid === comment.authorId)">
                                                    <div class="dropdown d-inline-block">
                                                        <button class="btn btn-link btn-sm p-0 text-secondary" data-bs-toggle="dropdown">
                                                            <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-three-dots-vertical" viewBox="0 0 16 16"><path d="M9.5 13a1.5 1.5 0 1 1-3 0 1.5 1.5 0 0 1 3 0zm0-5a1.5 1.5 0 1 1-3 0 1.5 1.5 0 0 1 3 0zm0-5a1.5 1.5 0 1 1-3 0 1.5 1.5 0 0 1 3 0z"/></svg>
                                                        </button>
                                                        <ul class="dropdown-menu">
                                                            <li><a class="dropdown-item" href="#" @click.prevent="editComment(thread.id, comment)">Edit</a></li>
                                                            <template x-if="$store.auth.isAdmin">
                                                                <li><a class="dropdown-item" href="#" @click.prevent="censorComment(thread.id, comment)" x-text="comment.censored ? 'Edit Redaction' : 'Redact'"></a></li>
                                                            </template>
                                                            <li><a class="dropdown-item text-danger" href="#" @click.prevent="deleteComment(thread.id, comment.id)">Delete</a></li>
                                                        </ul>
                                                    </div>
                                                </template>
                                            </div>
                                            <div class="mb-1" x-html="DOMPurify.sanitize(comment.content)"></div>
                                            <template x-if="comment.censored">
                                                <span class="badge bg-danger" style="font-size: 0.6em;">[Redacted by Staff]</span>
                                            </template>
                                            <div class="d-flex gap-2 align-items-center">
                                                <button class="btn btn-link btn-sm p-0 text-secondary text-decoration-none" @click="replyTo(thread, comment)">Reply</button>
                                                <div class="dropdown">
                                                    <button class="btn btn-link btn-sm p-0 text-secondary text-decoration-none" data-bs-toggle="dropdown">React</button>
                                                    <div class="dropdown-menu p-2" style="min-width: 220px;">
                                                        <div class="d-flex justify-content-between">
                                                            <button class="btn btn-sm btn-light p-1" @click="vote(thread.id, comment, 'üëç')">üëç</button>
                                                            <button class="btn btn-sm btn-light p-1" @click="vote(thread.id, comment, '‚ù§Ô∏è')">‚ù§Ô∏è</button>
                                                            <button class="btn btn-sm btn-light p-1" @click="vote(thread.id, comment, 'üòÇ')">üòÇ</button>
                                                            <button class="btn btn-sm btn-light p-1" @click="vote(thread.id, comment, 'üòÆ')">üòÆ</button>
                                                            <button class="btn btn-sm btn-light p-1" @click="vote(thread.id, comment, 'ÔøΩ')">üò¢</button>
                                                            <button class="btn btn-sm btn-light p-1" @click="vote(thread.id, comment, 'ÔøΩ')">üò°</button>
                                                        </div>
                                                    </div>
                                                </div>
                                            </div>
                                            
                                            <!-- Replies -->
                                            <div class="replies ms-4 mt-2 border-start ps-3">
                                                <template x-for="reply in getReplies(thread, comment.id)" :key="reply.id">
                                                    <div class="comment mb-2">
                                                        <div class="d-flex">
                                                            <div class="d-flex flex-column align-items-center me-2">
                                                                <button class="btn btn-link btn-sm p-0 text-secondary text-decoration-none" @click="vote(thread.id, reply, 'up')" :class="hasVoted(reply, 'up') ? 'text-primary' : ''">‚ñ≤</button>
                                                                <span class="small fw-bold" x-text="getVoteScore(reply)"></span>
                                                                <button class="btn btn-link btn-sm p-0 text-secondary text-decoration-none" @click="vote(thread.id, reply, 'down')" :class="hasVoted(reply, 'down') ? 'text-primary' : ''">‚ñº</button>
                                                            </div>
                                                            <div class="flex-grow-1">
                                                                <div class="d-flex align-items-center gap-2 mb-1">
                                                                    <img :src="getAuthor(reply.authorId).photoURL || './defaultuser.png'" class="profile-img-sm">
                                                                    <strong x-text="getAuthor(reply.authorId).displayName || 'Unknown'"></strong>
                                                                    <small class="text-secondary" x-text="formatDate(reply.createdAt)"></small>
                                                                    <div class="d-flex gap-1 ms-2">
                                                                        <template x-for="(count, emoji) in getReactions(reply)" :key="emoji">
                                                                            <span class="badge bg-dark border border-secondary text-secondary" x-text="emoji + ' ' + count" style="font-size: 0.7em;"></span>
                                                                        </template>
                                                                    </div>
                                                                    <template x-if="$store.auth.isAdmin || ($store.auth.user && $store.auth.user.uid === reply.authorId)">
                                                                        <div class="dropdown d-inline-block">
                                                                            <button class="btn btn-link btn-sm p-0 text-secondary" data-bs-toggle="dropdown">
                                                                                <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-three-dots-vertical" viewBox="0 0 16 16"><path d="M9.5 13a1.5 1.5 0 1 1-3 0 1.5 1.5 0 0 1 3 0zm0-5a1.5 1.5 0 1 1-3 0 1.5 1.5 0 0 1 3 0zm0-5a1.5 1.5 0 1 1-3 0 1.5 1.5 0 0 1 3 0z"/></svg>
                                                                            </button>
                                                                            <ul class="dropdown-menu">
                                                                                <li><a class="dropdown-item" href="#" @click.prevent="editComment(thread.id, reply)">Edit</a></li>
                                                                                <template x-if="$store.auth.isAdmin">
                                                                                    <li><a class="dropdown-item" href="#" @click.prevent="censorComment(thread.id, reply)" x-text="reply.censored ? 'Edit Redaction' : 'Redact'"></a></li>
                                                                                </template>
                                                                                <li><a class="dropdown-item text-danger" href="#" @click.prevent="deleteComment(thread.id, reply.id)">Delete</a></li>
                                                                            </ul>
                                                                        </div>
                                                                    </template>
                                                                </div>
                                                                <div class="mb-1" x-html="DOMPurify.sanitize(reply.content)"></div>
                                                                <template x-if="reply.censored">
                                                                    <span class="badge bg-danger" style="font-size: 0.6em;">[Redacted by Staff]</span>
                                                                </template>
                                                                <div class="d-flex gap-2 align-items-center">
                                                                    <button class="btn btn-link btn-sm p-0 text-secondary text-decoration-none" @click="replyTo(thread, reply)">Reply</button>
                                                                    <div class="dropdown">
                                                                        <button class="btn btn-link btn-sm p-0 text-secondary text-decoration-none" data-bs-toggle="dropdown">React</button>
                                                                        <div class="dropdown-menu p-2" style="min-width: 220px;">
                                                                            <div class="d-flex justify-content-between">
                                                                                <button class="btn btn-sm btn-light p-1" @click="vote(thread.id, reply, 'üëç')">üëç</button>
                                                                                <button class="btn btn-sm btn-light p-1" @click="vote(thread.id, reply, '‚ù§Ô∏è')">‚ù§Ô∏è</button>
                                                                                <button class="btn btn-sm btn-light p-1" @click="vote(thread.id, reply, 'üòÇ')">üòÇ</button>
                                                                                <button class="btn btn-sm btn-light p-1" @click="vote(thread.id, reply, 'üòÆ')">üòÆ</button>
                                                                                <button class="btn btn-sm btn-light p-1" @click="vote(thread.id, reply, 'üò¢')">üò¢</button>
                                                                                <button class="btn btn-sm btn-light p-1" @click="vote(thread.id, reply, 'üò°')">üò°</button>
                                                                            </div>
                                                                        </div>
                                                                    </div>
                                                                </div>
                                                            </div>
                                                        </div>
                                                    </div>
                                                </template>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            </template>
                        </div>
                        <template x-if="$store.auth.user">
                            <div class="mt-3">
                                <div x-init="
                                    $nextTick(() => {
                                        if (!thread.quill) {
                                            thread.quill = new Quill($el, { 
                                                theme: 'snow', 
                                                placeholder: 'Write a comment...', 
                                                modules: { toolbar: [['bold','italic','underline', 'strike'], ['link', 'blockquote', 'code-block'], ['clean']] } 
                                            });
                                        }
                                    })
                                " style="min-height: 100px; background: #222; color: #fff; border-radius: 0 0 5px 5px;"></div>
                                <div class="d-flex justify-content-end mt-2">
                                    <button class="btn btn-primary btn-sm" @click="postComment(thread.id)">Post Comment</button>
                                </div>
                            </div>
                        </template>
                    </div>
                </div>
            </template>
        </div>

        <div x-show="tab === 'messages'" x-data="messageData">
            <template x-if="!$store.auth.user">
                <div class="alert alert-info">Sign in to view messages</div>
            </template>
            <template x-if="$store.auth.user">
                <div class="row">
                    <div class="col-md-4 border-end">
                        <div class="d-flex justify-content-between align-items-center mb-3">
                            <h5 class="mb-0">Conversations</h5>
                            <button class="btn btn-primary btn-sm" @click="createConversation">New</button>
                        </div>
                        <div class="list-group">
                            <template x-for="conv in conversations" :key="conv.id">
                                <a href="#" class="list-group-item list-group-item-action" :class="{ 'active': selectedConv?.id === conv.id }" @click.prevent="selectConv(conv)">
                                    <div class="d-flex w-100 justify-content-between">
                                        <h6 class="mb-1" x-text="getConvName(conv)"></h6>
                                        <small x-text="formatDate(conv.lastMessageTime)"></small>
                                    </div>
                                    <p class="mb-1 small text-truncate" x-text="conv.lastMessage || 'No messages'"></p>
                                </a>
                            </template>
                        </div>
                    </div>
                    <div class="col-md-8">
                        <template x-if="!selectedConv">
                            <div class="text-center text-secondary py-5">Select a conversation</div>
                        </template>
                        <template x-if="selectedConv">
                            <div class="d-flex flex-column" style="height: 600px;">
                                <div class="border-bottom pb-2 mb-3">
                                    <strong x-text="getConvName(selectedConv)"></strong>
                                </div>
                                <div class="flex-grow-1 overflow-auto mb-3" id="msg-list">
                                    <template x-for="msg in messages" :key="msg.id">
                                        <div class="mb-2 d-flex" :class="msg.senderId === $store.auth.user.uid ? 'justify-content-end' : 'justify-content-start'" x-init="fetchAuthor(msg.senderId)">
                                            <div class="d-flex flex-column" :class="msg.senderId === $store.auth.user.uid ? 'align-items-end' : 'align-items-start'">
                                                <small class="text-secondary mb-1" style="font-size: 0.75em;" x-text="getAuthor(msg.senderId).displayName"></small>
                                                <div class="d-flex gap-2" :class="msg.senderId === $store.auth.user.uid ? 'flex-row-reverse' : 'flex-row'">
                                                    <img :src="getAuthor(msg.senderId).photoURL" class="rounded-circle" style="width: 24px; height: 24px; object-fit: cover;">
                                                    <div class="message-bubble p-2 rounded" :class="msg.senderId === $store.auth.user.uid ? 'bg-primary text-white' : 'bg-secondary'">
                                                        <div x-html="DOMPurify.sanitize(msg.content)"></div>
                                                        <small class="d-block text-end" style="font-size: 0.7em; opacity: 0.7;" x-text="formatDate(msg.createdAt)"></small>
                                                    </div>
                                                    <template x-if="msg.senderId === $store.auth.user.uid">
                                                        <div class="dropdown align-self-center">
                                                            <button class="btn btn-link btn-sm p-0 text-secondary" data-bs-toggle="dropdown">
                                                                <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-three-dots-vertical" viewBox="0 0 16 16"><path d="M9.5 13a1.5 1.5 0 1 1-3 0 1.5 1.5 0 0 1 3 0zm0-5a1.5 1.5 0 1 1-3 0 1.5 1.5 0 0 1 3 0zm0-5a1.5 1.5 0 1 1-3 0 1.5 1.5 0 0 1 3 0z"/></svg>
                                                            </button>
                                                            <ul class="dropdown-menu">
                                                                <li><a class="dropdown-item" href="#" @click.prevent="editMessage(msg)">Edit</a></li>
                                                                <li><a class="dropdown-item text-danger" href="#" @click.prevent="deleteMessage(msg.id)">Delete</a></li>
                                                            </ul>
                                                        </div>
                                                    </template>
                                                </div>
                                            </div>
                                        </div>
                                    </template>
                                </div>
                                <div class="input-group">
                                    <input type="text" class="form-control" x-model="newMessage" @keydown.enter="sendMessage">
                                    <button class="btn btn-primary" @click="sendMessage">Send</button>
                                </div>
                            </div>
                        </template>
                    </div>
                </div>
            </template>
        </div>
    </div>
</main>

<div id="footer-placeholder"></div>

<script type="module" src="./app.js"></script>
<script type="module">
    import { db, COLLECTIONS, collection, query, orderBy, getDocs, getDoc, addDoc, updateDoc, deleteDoc, doc, increment, serverTimestamp, where, onSnapshot } from './firebase-init.js';
    import { formatDate } from './helpers.js';

    document.addEventListener('alpine:init', () => {
        Alpine.data('forumData', () => ({
            threads: [],
            loading: true,
            showCreateModal: false,
            newThread: { title: '', category: '', tags: '' },
            quill: null,
            userCache: {},

            async init() {
                this.loadThreads();
                this.$watch('showCreateModal', value => {
                    if (value && !this.quill) {
                        this.$nextTick(() => {
                            this.quill = new Quill(this.$refs.createEditor, { theme: 'snow', placeholder: 'Describe your thread...' });
                        });
                    }
                });
            },

            async loadThreads() {
                const q = query(collection(db, COLLECTIONS.FORMS), orderBy('createdAt', 'desc'));
                const snap = await getDocs(q);
                
                // Fetch comments for all threads
                const threads = await Promise.all(snap.docs.map(async d => {
                    const threadData = { id: d.id, ...d.data(), expanded: true, comments: [], loadingComments: false, quill: null };
                    const cq = query(collection(db, COLLECTIONS.SUBMISSIONS(d.id)), orderBy('createdAt', 'asc'));
                    const cSnap = await getDocs(cq);
                    threadData.comments = cSnap.docs.map(cd => ({ id: cd.id, ...cd.data() }));
                    return threadData;
                }));
                
                this.threads = threads;
                
                // Collect ALL author IDs (threads + comments)
                const threadAuthors = this.threads.map(t => t.authorId);
                const commentAuthors = this.threads.flatMap(t => t.comments.map(c => c.authorId));
                const allAuthorIds = [...new Set([...threadAuthors, ...commentAuthors].filter(Boolean))];
                
                await Promise.all(allAuthorIds.map(id => this.fetchAuthor(id)));
                
                this.loading = false;
                
                // Init Quills
                this.$nextTick(() => {
                    this.threads.forEach(thread => {
                        if (Alpine.store('auth').user) {
                            const el = document.getElementById('editor-' + thread.id);
                            if (el) {
                                thread.quill = new Quill(el, { theme: 'snow', placeholder: 'Add a comment...', modules: { toolbar: [['bold','italic','underline'],['link'],['clean']] } });
                            }
                        }
                    });
                });
            },
            
            async fetchAuthor(uid) {
                if (!uid || this.userCache[uid]) return;
                try {
                    const snap = await getDoc(doc(db, 'user_profiles', uid));
                    if (snap.exists()) {
                        this.userCache[uid] = snap.data();
                    }
                } catch (e) { console.error('Failed to fetch author:', e); }
            },
            
            getAuthor(uid) {
                if (this.userCache[uid]) return this.userCache[uid];
                const store = Alpine.store('auth');
                if (store.user && store.user.uid === uid && store.profile) return store.profile;
                return { displayName: 'Unknown', handle: '', photoURL: './defaultuser.png' };
            },

            async createThread() {
                if (!this.quill) return;
                const description = this.quill.root.innerHTML;
                const user = Alpine.store('auth').user;
                if (!user) return;

                await addDoc(collection(db, COLLECTIONS.FORMS), {
                    ...this.newThread,
                    description,
                    authorId: user.uid,
                    createdBy: Alpine.store('auth').profile?.displayName || 'Anonymous',
                    createdAt: serverTimestamp(),
                    updatedAt: serverTimestamp(),
                    commentCount: 0,
                    votes: 0
                });
                this.showCreateModal = false;
                this.newThread = { title: '', category: '', tags: '' };
                this.quill.root.innerHTML = '';
                this.loadThreads();
            },

            async toggleThread(thread) {
                thread.expanded = !thread.expanded;
                if (thread.expanded && thread.comments.length === 0) {
                    thread.loadingComments = true;
                    const q = query(collection(db, COLLECTIONS.SUBMISSIONS(thread.id)), orderBy('createdAt', 'asc'));
                    const snap = await getDocs(q);
                    thread.comments = snap.docs.map(d => ({ id: d.id, ...d.data() }));
                    
                    const commentAuthorIds = [...new Set(thread.comments.map(c => c.authorId).filter(Boolean))];
                    await Promise.all(commentAuthorIds.map(id => this.fetchAuthor(id)));
                    
                    thread.loadingComments = false;
                    
                    this.$nextTick(() => {
                        if (!thread.quill && Alpine.store('auth').user) {
                            const el = document.getElementById('editor-' + thread.id);
                            if (el) {
                                thread.quill = new Quill(el, { theme: 'snow', placeholder: 'Add a comment...', modules: { toolbar: [['bold','italic','underline'],['link'],['clean']] } });
                            }
                        }
                    });
                }
            },

            getReplies(thread, parentId) {
                return thread.comments.filter(c => c.parentCommentId === parentId);
            },

            formatDate(ts) { return formatDate(ts); },

            getThreadMeta(thread) {
                let authorName = 'System';
                let authorPic = '';
                
                if (thread.createdBy !== 'admin' && thread.authorId) {
                    const author = this.getAuthor(thread.authorId);
                    authorName = author.displayName;
                    authorPic = `<img src="${author.photoURL || './defaultuser.png'}" class="profile-img-sm me-1" alt="">`;
                }

                const cat = thread.category ? thread.category.charAt(0).toUpperCase() + thread.category.slice(1) : 'General';
                const date = formatDate(thread.createdAt);
                const comments = `${thread.commentCount || 0} comments`;
                const tags = thread.tags ? `<span class="badge bg-secondary me-1">${thread.tags}</span>` : '';
                
                return `${tags} ${authorPic} ${authorName} ‚Ä¢ ${cat} ‚Ä¢ ${date} ‚Ä¢ ${comments}`;
            },

            async softDeleteThread(thread) {
                if (!confirm(thread.censored ? 'Un-censor this thread?' : 'Censor this thread (soft delete)?')) return;
                await updateDoc(doc(db, COLLECTIONS.FORMS, thread.id), { censored: !thread.censored });
                thread.censored = !thread.censored;
            },
            
            async censorComment(forumId, comment) {
                 let quillInstance = null;
                 const { value } = await Swal.fire({
                    title: 'Redact Comment',
                    html: '<div id="swal-censor-editor" style="height: 150px; text-align: left; background: #222; color: white;"></div>',
                    showCancelButton: true,
                    didOpen: () => {
                        quillInstance = new Quill('#swal-censor-editor', {
                            theme: 'snow',
                            modules: { toolbar: [['bold','italic','underline', 'strike'], ['link', 'blockquote', 'code-block'], ['clean']] }
                        });
                        quillInstance.root.innerHTML = comment.content;
                    },
                    preConfirm: () => {
                        return quillInstance.root.innerHTML;
                    }
                });

                if (value !== undefined) {
                    await updateDoc(doc(db, COLLECTIONS.SUBMISSIONS(forumId), comment.id), { 
                        content: value, 
                        censored: true 
                    });
                    comment.content = value;
                    comment.censored = true;
                }
            },

            async deleteThread(threadId) {
                if (!confirm('Permanently delete this thread?')) return;
                await deleteDoc(doc(db, COLLECTIONS.FORMS, threadId));
                this.threads = this.threads.filter(t => t.id !== threadId);
                Swal.fire('Deleted', 'Thread deleted', 'success');
            },

            async editThread(thread) {
                const { value: formValues } = await Swal.fire({
                    title: 'Edit Thread',
                    html:
                        `<input id="swal-input1" class="swal2-input" placeholder="Title" value="${thread.title}">` +
                        `<input id="swal-input2" class="swal2-input" placeholder="Tags" value="${thread.tags || ''}">` +
                        `<select id="swal-input3" class="swal2-input"><option value="announcements" ${thread.category === 'announcements' ? 'selected' : ''}>Announcements</option><option value="gaming" ${thread.category === 'gaming' ? 'selected' : ''}>Gaming</option><option value="discussion" ${thread.category === 'discussion' ? 'selected' : ''}>Discussion</option><option value="support" ${thread.category === 'support' ? 'selected' : ''}>Support</option></select>`,
                    focusConfirm: false,
                    preConfirm: () => {
                        return [
                            document.getElementById('swal-input1').value,
                            document.getElementById('swal-input2').value,
                            document.getElementById('swal-input3').value
                        ]
                    }
                });

                if (formValues) {
                    await updateDoc(doc(db, COLLECTIONS.FORMS, thread.id), {
                        title: formValues[0],
                        tags: formValues[1],
                        category: formValues[2],
                        updatedAt: serverTimestamp()
                    });
                    thread.title = formValues[0];
                    thread.tags = formValues[1];
                    thread.category = formValues[2];
                    Swal.fire('Success', 'Thread updated', 'success');
                }
            },

            async postComment(forumId) {
                const thread = this.threads.find(t => t.id === forumId);
                if (!thread || !thread.quill) return;
                const content = thread.quill.root.innerHTML;
                if (!content || content === '<p><br></p>') return;

                const user = Alpine.store('auth').user;
                const profile = Alpine.store('auth').profile;
                
                await addDoc(collection(db, COLLECTIONS.SUBMISSIONS(forumId)), {
                    content,
                    authorId: user.uid,
                    authorName: profile?.displayName || 'Anonymous',
                    authorPhoto: profile?.photoURL || './defaultuser.png',
                    createdAt: serverTimestamp(),
                    parentCommentId: null
                });
                
                await updateDoc(doc(db, COLLECTIONS.FORMS, forumId), { commentCount: increment(1) });
                thread.quill.root.innerHTML = '';
                
                const q = query(collection(db, COLLECTIONS.SUBMISSIONS(forumId)), orderBy('createdAt', 'asc'));
                const snap = await getDocs(q);
                thread.comments = snap.docs.map(d => ({ id: d.id, ...d.data() }));
            },

            async vote(forumId, comment, type) {
                const user = Alpine.store('auth').user;
                if (!user) return Swal.fire('Error', 'Sign in to vote', 'error');
                
                const reactions = comment.reactions || {};
                const uid = user.uid;
                
                if (type === 'up' || type === 'down') {
                    const key = `${type}_${uid}`;
                    const otherKey = type === 'up' ? `down_${uid}` : `up_${uid}`;
                    
                    if (reactions[key]) delete reactions[key];
                    else {
                        reactions[key] = true;
                        delete reactions[otherKey];
                    }
                } else {
                    const key = `${type}_${uid}`;
                    // Clear other emoji reactions for this user
                    Object.keys(reactions).forEach(k => {
                        const [emoji, u] = k.split('_');
                        if (u === uid && emoji !== 'up' && emoji !== 'down') {
                            delete reactions[k];
                        }
                    });
                    // Toggle
                    // We just deleted it if it was there (in the loop above if we didn't check key specifically)
                    // Actually the loop deletes ALL emojis for this user.
                    // So if we want to toggle off, we need to know if it was there BEFORE the loop.
                    // But wait, the loop deletes 'reactions[k]'.
                    // If 'key' was in reactions, it gets deleted.
                    // So if we want to toggle, we just check if we should add it back.
                    // But we want to toggle: Click ‚ù§Ô∏è -> Add ‚ù§Ô∏è. Click ‚ù§Ô∏è again -> Remove ‚ù§Ô∏è.
                    // Click ‚ù§Ô∏è then üòÇ -> Remove ‚ù§Ô∏è, Add üòÇ.
                    
                    // Let's check existence first
                    const wasThere = reactions[key];
                    
                    // Clear all emojis
                    Object.keys(reactions).forEach(k => {
                        const [emoji, u] = k.split('_');
                        if (u === uid && emoji !== 'up' && emoji !== 'down') {
                            delete reactions[k];
                        }
                    });
                    
                    if (!wasThere) reactions[key] = true;
                }
                
                await updateDoc(doc(db, COLLECTIONS.SUBMISSIONS(forumId), comment.id), { reactions });
                comment.reactions = reactions;
            },

            hasVoted(comment, type) {
                const user = Alpine.store('auth').user;
                return user && comment.reactions && comment.reactions[`${type}_${user.uid}`];
            },

            getVoteScore(comment) {
                if (!comment.reactions) return 0;
                let score = 0;
                Object.keys(comment.reactions).forEach(k => {
                    if (k.startsWith('up_')) score++;
                    if (k.startsWith('down_')) score--;
                });
                return score;
            },

            getReactions(comment) {
                if (!comment.reactions) return {};
                const counts = {};
                Object.keys(comment.reactions).forEach(k => {
                    const emoji = k.split('_')[0];
                    if (emoji !== 'up' && emoji !== 'down') {
                        counts[emoji] = (counts[emoji] || 0) + 1;
                    }
                });
                return counts;
            },
            
            async replyTo(thread, parentComment) {
                let quillInstance = null;
                const { value } = await Swal.fire({
                    title: 'Reply',
                    html: '<div id="swal-reply-editor" style="height: 150px; text-align: left; background: #222; color: white;"></div>',
                    showCancelButton: true,
                    didOpen: () => {
                        quillInstance = new Quill('#swal-reply-editor', {
                            theme: 'snow',
                            placeholder: 'Write your reply...',
                            modules: { toolbar: [['bold','italic','underline', 'strike'], ['link', 'blockquote', 'code-block'], ['clean']] }
                        });
                    },
                    preConfirm: () => {
                        const content = quillInstance.root.innerHTML;
                        if (!content || content === '<p><br></p>') Swal.showValidationMessage('Please enter a reply');
                        return content;
                    }
                });
                if (value) {
                    const user = Alpine.store('auth').user;
                    const profile = Alpine.store('auth').profile;
                    
                    // Flatten threading: If parentComment is already a reply, use its parent.
                    const actualParentId = parentComment.parentCommentId || parentComment.id;
                    
                    await addDoc(collection(db, COLLECTIONS.SUBMISSIONS(thread.id)), {
                        content: value,
                        authorId: user.uid,
                        authorName: profile?.displayName || 'Anonymous',
                        authorPhoto: profile?.photoURL || './defaultuser.png',
                        createdAt: serverTimestamp(),
                        parentCommentId: actualParentId
                    });
                    await updateDoc(doc(db, COLLECTIONS.FORMS, thread.id), { commentCount: increment(1) });
                    
                    const q = query(collection(db, COLLECTIONS.SUBMISSIONS(thread.id)), orderBy('createdAt', 'asc'));
                    const snap = await getDocs(q);
                    thread.comments = snap.docs.map(d => ({ id: d.id, ...d.data() }));
                }
            },

            async deleteComment(forumId, commentId) {
                if (confirm('Delete this comment?')) {
                    await updateDoc(doc(db, COLLECTIONS.FORMS, forumId), { commentCount: increment(-1) });
                    await deleteDoc(doc(db, COLLECTIONS.SUBMISSIONS(forumId), commentId));
                    const q = query(collection(db, COLLECTIONS.SUBMISSIONS(forumId)), orderBy('createdAt', 'asc'));
                    const snap = await getDocs(q);
                    const thread = this.threads.find(t => t.id === forumId);
                    if (thread) thread.comments = snap.docs.map(d => ({ id: d.id, ...d.data() }));
                }
            },
            
            async editComment(forumId, comment) {
                 let quillInstance = null;
                 const { value } = await Swal.fire({
                    title: 'Edit Comment',
                    html: '<div id="swal-edit-editor" style="height: 150px; text-align: left; background: #222; color: white;"></div>',
                    showCancelButton: true,
                    didOpen: () => {
                        quillInstance = new Quill('#swal-edit-editor', {
                            theme: 'snow',
                            modules: { toolbar: [['bold','italic','underline', 'strike'], ['link', 'blockquote', 'code-block'], ['clean']] }
                        });
                        quillInstance.root.innerHTML = comment.content;
                    },
                    preConfirm: () => {
                        return quillInstance.root.innerHTML;
                    }
                });
                if (value) {
                    await updateDoc(doc(db, COLLECTIONS.SUBMISSIONS(forumId), comment.id), { content: value });
                    comment.content = value;
                }
            }
        }));

        Alpine.data('messageData', () => ({
            conversations: [],
            selectedConv: null,
            messages: [],
            newMessage: '',
            unsubscribe: null,

            userCache: {},

            init() {
                this.$watch('$store.auth.user', user => {
                    if (user) this.loadConversations();
                    else { this.conversations = []; this.selectedConv = null; }
                });
                if (Alpine.store('auth').user) this.loadConversations();
            },

            async fetchAuthor(uid) {
                if (!uid || this.userCache[uid]) return;
                try {
                    const snap = await getDoc(doc(db, 'user_profiles', uid));
                    if (snap.exists()) {
                        this.userCache[uid] = snap.data();
                    }
                } catch (e) { console.error('Failed to fetch author:', e); }
            },
            
            getAuthor(uid) {
                if (this.userCache[uid]) return this.userCache[uid];
                const store = Alpine.store('auth');
                if (store.user && store.user.uid === uid && store.profile) return store.profile;
                return { displayName: 'Unknown', handle: '', photoURL: './defaultuser.png' };
            },

            async loadConversations() {
                const user = Alpine.store('auth').user;
                if (!user) return;
                const q = query(collection(db, COLLECTIONS.CONVERSATIONS), where('participants', 'array-contains', user.uid));
                const snap = await getDocs(q);
                this.conversations = snap.docs.map(d => ({ id: d.id, ...d.data() }));
                
                const participantIds = [...new Set(this.conversations.flatMap(c => c.participants))];
                await Promise.all(participantIds.map(id => this.fetchAuthor(id)));
            },

            getConvName(conv) {
                const user = Alpine.store('auth').user;
                if (conv.name && conv.name !== 'Notes') return conv.name;
                if (conv.participants.length === 1) return 'Notes';
                
                const otherIds = conv.participants.filter(id => id !== user.uid);
                if (otherIds.length === 0) return 'Notes';
                
                const names = otherIds.map(id => this.getAuthor(id).displayName).join(', ');
                return names || 'Chat'; 
            },

            async selectConv(conv) {
                this.selectedConv = conv;
                if (this.unsubscribe) this.unsubscribe();
                
                const q = query(collection(db, COLLECTIONS.CONV_MESSAGES(conv.id)), orderBy('createdAt', 'asc'));
                this.unsubscribe = onSnapshot(q, snap => {
                    this.messages = snap.docs.map(d => ({ id: d.id, ...d.data() }));
                    this.$nextTick(() => {
                        const el = document.getElementById('msg-list');
                        if (el) el.scrollTop = el.scrollHeight;
                    });
                });
            },

            async sendMessage() {
                if (!this.newMessage.trim() || !this.selectedConv) return;
                const user = Alpine.store('auth').user;
                await addDoc(collection(db, COLLECTIONS.CONV_MESSAGES(this.selectedConv.id)), {
                    content: this.newMessage,
                    senderId: user.uid,
                    createdAt: serverTimestamp()
                });
                await updateDoc(doc(db, COLLECTIONS.CONVERSATIONS, this.selectedConv.id), {
                    lastMessage: this.newMessage,
                    lastMessageTime: serverTimestamp()
                });
                this.newMessage = '';
            },

            async deleteMessage(msgId) {
                if (confirm('Delete message?')) {
                    await deleteDoc(doc(db, COLLECTIONS.CONV_MESSAGES(this.selectedConv.id), msgId));
                }
            },

            async editMessage(msg) {
                 let quillInstance = null;
                 const { value } = await Swal.fire({
                    title: 'Edit Message',
                    html: '<div id="swal-msg-editor" style="height: 150px; text-align: left; background: #222; color: white;"></div>',
                    showCancelButton: true,
                    didOpen: () => {
                        quillInstance = new Quill('#swal-msg-editor', {
                            theme: 'snow',
                            modules: { toolbar: [['bold','italic','underline', 'strike'], ['link', 'blockquote', 'code-block'], ['clean']] }
                        });
                        quillInstance.root.innerHTML = msg.content;
                    },
                    preConfirm: () => {
                        return quillInstance.root.innerHTML;
                    }
                });
                if (value) {
                    await updateDoc(doc(db, COLLECTIONS.CONV_MESSAGES(this.selectedConv.id), msg.id), { content: value });
                }
            },

            async createConversation() {
                const snap = await getDocs(collection(db, COLLECTIONS.USER_PROFILES));
                const users = snap.docs.map(d => ({ id: d.id, ...d.data() }));
                const currentUser = Alpine.store('auth').user;
                const otherUsers = users.filter(u => u.id !== currentUser.uid);
                
                if (otherUsers.length === 0) {
                    Swal.fire('No users found', 'There are no other users to message.', 'info');
                    return;
                }
                
                const options = otherUsers.map(u => `<option value="${u.id}">${u.displayName || u.email || 'Unknown'}</option>`).join('');
                
                const { value: selectedUid } = await Swal.fire({
                    title: 'New Conversation',
                    html: `<select id="new-conv-user" class="form-select">${options}</select>`,
                    preConfirm: () => document.getElementById('new-conv-user').value,
                    showCancelButton: true
                });
                
                if (selectedUid) {
                    const existing = this.conversations.find(c => c.participants.includes(selectedUid) && c.participants.length === 2);
                    if (existing) {
                        this.selectConv(existing);
                        return;
                    }
                    
                    await addDoc(collection(db, COLLECTIONS.CONVERSATIONS), {
                        participants: [currentUser.uid, selectedUid],
                        createdAt: serverTimestamp(),
                        lastMessageTime: serverTimestamp()
                    });
                    
                    this.loadConversations();
                }
            },
            
            formatDate(ts) { return formatDate(ts); }
        }));
    });
</script>
<script src="https://cdn.jsdelivr.net/npm/alpinejs@3.13.3/dist/cdn.min.js" defer></script>
</body>
</html>
